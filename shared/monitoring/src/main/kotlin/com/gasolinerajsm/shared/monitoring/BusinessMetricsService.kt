package com.gasolinerajsm.shared.monitoring

import io.micrometer.core.instrument.*
import org.springframework.stereotype.Service
import java.time.Duration
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicLong

/**
 * Business Metrics Service
 * Provides business-specific metrics for Gasolinera JSM operations
 */
@Service
class BusinessMetricsService(
    private val meterRegistry: MeterRegistry,
    private val metricsProperties: MetricsProperties
) {

    // Counters for business events
    private val counters = ConcurrentHashMap<String, Counter>()

    // Gauges for current state
    private val gauges = ConcurrentHashMap<String, AtomicLong>()

    // Timers for operation duration
    private val timers = ConcurrentHashMap<String, Timer>()

    init {
        initializeBusinessMetrics()
    }

    /**
     * Initialize business metrics
     */
    private fun initializeBusinessMetrics() {
        if (metricsProperties.business.enabled) {
            initializeCouponMetrics()
            initializeRaffleMetrics()
            initializeStationMetrics()
            initializeUserMetrics()
            initializeRedemptionMetrics()
            initializeAdvertisementMetrics()
        }
    }

    // ==================== COUPON METRICS ====================

    private fun initializeCouponMetrics() {
        if (!metricsProperties.business.coupons.enabled) return

        // Coupon generation metrics
        getOrCreateCounter("coupons.generated.total", "Total coupons generated")
        getOrCreateCounter("coupons.generated.by_campaign", "Coupons generated by campaign", "campaign_id")

        // Coupon usage metrics
        getOrCreateCounter("coupons.used.total", "Total coupons used")
        getOrCreateCounter("coupons.used.by_station", "Coupons used by station", "station_id")
        getOrCreateCounter("coupons.used.by_type", "Coupons used by type", "coupon_type")

        // Coupon validation metrics
        getOrCreateCounter("coupons.validated.total", "Total coupon validations")
        getOrCreateCounter("coupons.validated.success", "Successful coupon validations")
        getOrCreateCounter("coupons.validated.failed", "Failed coupon validations")

        // Coupon state gauges
        registerGauge("coupons.active.count", "Active coupons count")
        registerGauge("coupons.expired.count", "Expired coupons count")
        registerGauge("coupons.pending.count", "Pending coupons count")

        // Coupon operation timers
        getOrCreateTimer("coupons.generation.duration", "Coupon generation duration")
        getOrCreateTimer("coupons.validation.duration", "Coupon validation duration")
        getOrCreateTimer("coupons.usage.duration", "Coupon usage duration")
    }

    fun recordCouponGenerated(campaignId: String, count: Int = 1) {
        incrementCounter("coupons.generated.total", count.toDouble())
        incrementCounter("coupons.generated.by_campaign", count.toDouble(), "campaign_id", campaignId)
    }

    fun recordCouponUsed(stationId: String, couponType: String) {
        incrementCounter("coupons.used.total")
        incrementCounter("coupons.used.by_station", "station_id", stationId)
        incrementCounter("coupons.used.by_type", "coupon_type", couponType)
    }

    fun recordCouponValidation(success: Boolean, duration: Duration) {
        incrementCounter("coupons.validated.total")
        if (success) {
            incrementCounter("coupons.validated.success")
        } else {
            incrementCounter("coupons.validated.failed")
        }
        recordTimer("coupons.validation.duration", duration)
    }

    fun updateCouponCounts(active: Long, expired: Long, pending: Long) {
        updateGauge("coupons.active.count", active)
        updateGauge("coupons.expired.count", expired)
        updateGauge("coupons.pending.count", pending)
    }

    // ==================== RAFFLE METRICS ====================

    private fun initializeRaffleMetrics() {
        if (!metricsProperties.business.raffles.enabled) return

        // Raffle participation metrics
        getOrCreateCounter("raffles.participations.total", "Total raffle participations")
        getOrCreateCounter("raffles.participations.by_raffle", "Participations by raffle", "raffle_id")
        getOrCreateCounter("raffles.participations.by_user", "Participations by user", "user_id")

        // Raffle draw metrics
        getOrCreateCounter("raffles.draws.total", "Total raffle draws")
        getOrCreateCounter("raffles.draws.completed", "Completed raffle draws")
        getOrCreateCounter("raffles.draws.failed", "Failed raffle draws")

        // Winner metrics
        getOrCreateCounter("raffles.winners.total", "Total raffle winners")
        getOrCreateCounter("raffles.winners.by_prize_type", "Winners by prize type", "prize_type")

        // Raffle state gauges
        registerGauge("raffles.active.count", "Active raffles count")
        registerGauge("raffles.pending.count", "Pending raffles count")
        registerGauge("raffles.completed.count", "Completed raffles count")

        // Raffle operation timers
        getOrCreateTimer("raffles.draw.duration", "Raffle draw duration")
        getOrCreateTimer("raffles.participation.duration", "Raffle participation duration")
    }

    fun recordRaffleParticipation(raffleId: String, userId: String) {
        incrementCounter("raffles.participations.total")
        incrementCounter("raffles.participations.by_raffle", "raffle_id", raffleId)
        incrementCounter("raffles.participations.by_user", "user_id", userId)
    }

    fun recordRaffleDraw(success: Boolean, duration: Duration) {
        incrementCounter("raffles.draws.total")
        if (success) {
            incrementCounter("raffles.draws.completed")
        } else {
            incrementCounter("raffles.draws.failed")
        }
        recordTimer("raffles.draw.duration", duration)
    }

    fun recordRaffleWinner(prizeType: String) {
        incrementCounter("raffles.winners.total")
        incrementCounter("raffles.winners.by_prize_type", "prize_type", prizeType)
    }

    // ==================== STATION METRICS ====================

    private fun initializeStationMetrics() {
        if (!metricsProperties.business.stations.enabled) return

        // Fuel price metrics
        getOrCreateCounter("stations.fuel_price_updates.total", "Total fuel price updates")
        getOrCreateCounter("stations.fuel_price_updates.by_station", "Price updates by station", "station_id")

        // Transaction metrics
        getOrCreateCounter("stations.transactions.total", "Total station transactions")
        getOrCreateCounter("stations.transactions.by_type", "Transactions by type", "transaction_type")
        getOrCreateCounter("stations.transactions.by_station", "Transactions by station", "station_id")

        // Inventory metrics
        registerGauge("stations.fuel_inventory.liters", "Fuel inventory in liters", "station_id", "fuel_type")
        registerGauge("stations.inventory.low_stock.count", "Low stock alerts count")

        // Station operation timers
        getOrCreateTimer("stations.transaction.duration", "Station transaction duration")
        getOrCreateTimer("stations.inventory_check.duration", "Inventory check duration")
    }

    fun recordFuelPriceUpdate(stationId: String) {
        incrementCounter("stations.fuel_price_updates.total")
        incrementCounter("stations.fuel_price_updates.by_station", "station_id", stationId)
    }

    fun recordStationTransaction(stationId: String, transactionType: String, duration: Duration) {
        incrementCounter("stations.transactions.total")
        incrementCounter("stations.transactions.by_type", "transaction_type", transactionType)
        incrementCounter("stations.transactions.by_station", "station_id", stationId)
        recordTimer("stations.transaction.duration", duration)
    }

    fun updateFuelInventory(stationId: String, fuelType: String, liters: Double) {
        val gaugeName = "stations.fuel_inventory.liters"
        val gauge = Gauge.builder(gaugeName)
            .description("Fuel inventory in liters")
            .tags("station_id", stationId, "fuel_type", fuelType)
            .register(meterRegistry) { liters }
    }

    // ==================== USER METRICS ====================

    private fun initializeUserMetrics() {
        if (!metricsProperties.business.users.enabled) return

        // User registration metrics
        getOrCreateCounter("users.registrations.total", "Total user registrations")
        getOrCreateCounter("users.registrations.by_role", "Registrations by role", "role")
        getOrCreateCounter("users.registrations.by_station", "Registrations by station", "station_id")

        // User login metrics
        getOrCreateCounter("users.logins.total", "Total user logins")
        getOrCreateCounter("users.logins.success", "Successful logins")
        getOrCreateCounter("users.logins.failed", "Failed logins")
        getOrCreateCounter("users.logins.by_role", "Logins by role", "role")

        // User activity metrics
        getOrCreateCounter("users.activity.total", "Total user activities")
        getOrCreateCounter("users.activity.by_type", "Activities by type", "activity_type")

        // User state gauges
        registerGauge("users.active.count", "Active users count")
        registerGauge("users.inactive.count", "Inactive users count")
        registerGauge("users.online.count", "Online users count")

        // User operation timers
        getOrCreateTimer("users.registration.duration", "User registration duration")
        getOrCreateTimer("users.authentication.duration", "User authentication duration")
    }

    fun recordUserRegistration(role: String, stationId: String?, duration: Duration) {
        incrementCounter("users.registrations.total")
        incrementCounter("users.registrations.by_role", "role", role)
        stationId?.let {
            incrementCounter("users.registrations.by_station", "station_id", it)
        }
        recordTimer("users.registration.duration", duration)
    }

    fun recordUserLogin(success: Boolean, role: String, duration: Duration) {
        incrementCounter("users.logins.total")
        if (success) {
            incrementCounter("users.logins.success")
            incrementCounter("users.logins.by_role", "role", role)
        } else {
            incrementCounter("users.logins.failed")
        }
        recordTimer("users.authentication.duration", duration)
    }

    fun recordUserActivity(activityType: String) {
        incrementCounter("users.activity.total")
        incrementCounter("users.activity.by_type", "activity_type", activityType)
    }

    // ==================== REDEMPTION METRICS ====================

    private fun initializeRedemptionMetrics() {
        // Redemption processing metrics
        getOrCreateCounter("redemptions.processed.total", "Total redemptions processed")
        getOrCreateCounter("redemptions.processed.success", "Successful redemptions")
        getOrCreateCounter("redemptions.processed.failed", "Failed redemptions")
        getOrCreateCounter("redemptions.processed.by_type", "Redemptions by type", "redemption_type")

        // Ticket generation metrics
        getOrCreateCounter("tickets.generated.total", "Total tickets generated")
        getOrCreateCounter("tickets.generated.by_multiplier", "Tickets by multiplier", "multiplier")

        // Redemption timers
        getOrCreateTimer("redemptions.processing.duration", "Redemption processing duration")
        getOrCreateTimer("tickets.generation.duration", "Ticket generation duration")
    }

    fun recordRedemptionProcessed(success: Boolean, redemptionType: String, duration: Duration) {
        incrementCounter("redemptions.processed.total")
        if (success) {
            incrementCounter("redemptions.processed.success")
        } else {
            incrementCounter("redemptions.processed.failed")
        }
        incrementCounter("redemptions.processed.by_type", "redemption_type", redemptionType)
        recordTimer("redemptions.processing.duration", duration)
    }

    fun recordTicketsGenerated(count: Int, multiplier: Double, duration: Duration) {
        incrementCounter("tickets.generated.total", count.toDouble())
        incrementCounter("tickets.generated.by_multiplier", count.toDouble(), "multiplier", multiplier.toString())
        recordTimer("tickets.generation.duration", duration)
    }

    // ==================== ADVERTISEMENT METRICS ====================

    private fun initializeAdvertisementMetrics() {
        // Ad engagement metrics
        getOrCreateCounter("ads.impressions.total", "Total ad impressions")
        getOrCreateCounter("ads.clicks.total", "Total ad clicks")
        getOrCreateCounter("ads.conversions.total", "Total ad conversions")
        getOrCreateCounter("ads.engagement.by_type", "Engagement by ad type", "ad_type")

        // Ad performance gauges
        registerGauge("ads.ctr.current", "Current click-through rate")
        registerGauge("ads.conversion_rate.current", "Current conversion rate")

        // Ad operation timers
        getOrCreateTimer("ads.serving.duration", "Ad serving duration")
        getOrCreateTimer("ads.targeting.duration", "Ad targeting duration")
    }

    fun recordAdImpression(adType: String) {
        incrementCounter("ads.impressions.total")
        incrementCounter("ads.engagement.by_type", "ad_type", adType)
    }

    fun recordAdClick(adType: String) {
        incrementCounter("ads.clicks.total")
        incrementCounter("ads.engagement.by_type", "ad_type", adType)
    }

    fun recordAdConversion(adType: String) {
        incrementCounter("ads.conversions.total")
        incrementCounter("ads.engagement.by_type", "ad_type", adType)
    }

    // ==================== UTILITY METHODS ====================

    private fun getOrCreateCounter(name: String, description: String, vararg tags: String): Counter {
        val key = "$name:${tags.joinToString(":")}"
        return counters.computeIfAbsent(key) {
            Counter.builder(name)
                .description(description)
                .tags(*tags)
                .register(meterRegistry)
        }
    }

    private fun incrementCounter(name: String, increment: Double = 1.0, vararg tags: String) {
        getOrCreateCounter(name, "", *tags).increment(increment)
    }

    private fun registerGauge(name: String, description: String, vararg tags: String): AtomicLong {
        val key = "$name:${tags.joinToString(":")}"
        return gauges.computeIfAbsent(key) { _ ->
            val atomicValue = AtomicLong(0)
            Gauge.builder(name)
                .description(description)
                .tags(*tags)
                .register(meterRegistry, atomicValue) { it.get().toDouble() }
            atomicValue
        }
    }

    private fun updateGauge(name: String, value: Long, vararg tags: String) {
        val key = "$name:${tags.joinToString(":")}"
        gauges[key]?.set(value)
    }

    private fun getOrCreateTimer(name: String, description: String, vararg tags: String): Timer {
        val key = "$name:${tags.joinToString(":")}"
        return timers.computeIfAbsent(key) {
            Timer.builder(name)
                .description(description)
                .tags(*tags)
                .register(meterRegistry)
        }
    }

    private fun recordTimer(name: String, duration: Duration, vararg tags: String) {
        getOrCreateTimer(name, "", *tags).record(duration)
    }

    /**
     * Get current metrics summary
     */
    fun getMetricsSummary(): Map<String, Any> {
        return mapOf(
            "counters" to counters.keys.size,
            "gauges" to gauges.keys.size,
            "timers" to timers.keys.size,
            "total_metrics" to (counters.size + gauges.size + timers.size)
        )
    }

    /**
     * Reset all metrics (for testing)
     */
    fun resetMetrics() {
        counters.clear()
        gauges.clear()
        timers.clear()
    }
}