package com.gasolinerajsm.shared.vault

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.boot.context.properties.EnableConfigurationProperties
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Primary
import org.springframework.core.env.Environment
import javax.sql.DataSource
import org.springframework.boot.jdbc.DataSourceBuilder
import org.springframework.scheduling.annotation.EnableScheduling
import org.springframework.scheduling.annotation.Scheduled
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.data.redis.connection.RedisConnectionFactory
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory
import org.springframework.data.redis.connection.RedisStandaloneConfiguration
import org.springframework.amqp.rabbit.connection.ConnectionFactory
import org.springframework.amqp.rabbit.connection.CachingConnectionFactory
import java.util.concurrent.ConcurrentHashMap

/**\n * Vault Configuration for Spring Boot Integration\n * Provides beans configured with secrets from Vault\n */\n@Configuration\n@EnableConfigurationProperties(VaultProperties::class)\n@EnableScheduling\nclass VaultConfiguration {\n    \n    companion object {\n        private val logger = LoggerFactory.getLogger(VaultConfiguration::class.java)\n    }\n    \n    @Autowired\n    private lateinit var vaultClient: VaultClient\n    \n    @Autowired\n    private lateinit var environment: Environment\n    \n    private val dynamicDataSources = ConcurrentHashMap<String, DataSource>()\n    \n    /**\n     * Primary DataSource configured with Vault credentials\n     */\n    @Bean\n    @Primary\n    @ConditionalOnProperty(name = ["vault.database.enabled"], havingValue = "true", matchIfMissing = true)\n    fun vaultDataSource(): DataSource {\n        return createDataSourceFromVault("gasolinera-readwrite")\n    }\n    \n    /**\n     * Read-only DataSource for reporting and analytics\n     */\n    @Bean("readOnlyDataSource")\n    @ConditionalOnProperty(name = ["vault.database.enabled"], havingValue = "true", matchIfMissing = true)\n    fun readOnlyDataSource(): DataSource {\n        return createDataSourceFromVault("gasolinera-readonly")\n    }\n    \n    /**\n     * Create DataSource using Vault database credentials\n     */\n    private fun createDataSourceFromVault(role: String): DataSource {\n        try {\n            val credentials = vaultClient.getDatabaseCredentials(role)\n            val dbConfig = vaultClient.getSecret("shared/database")\n                ?: throw VaultException("Database configuration not found in Vault")\n            \n            val host = dbConfig["host"] as? String ?: "localhost"\n            val port = dbConfig["port"] as? String ?: "5432"\n            val database = dbConfig["database"] as? String ?: "gasolinera_db"\n            \n            val jdbcUrl = "jdbc:postgresql://$host:$port/$database"\n            \n            logger.info("Creating DataSource for role: $role with user: ${credentials.username}")\n            \n            return DataSourceBuilder.create()\n                .driverClassName("org.postgresql.Driver")\n                .url(jdbcUrl)\n                .username(credentials.username)\n                .password(credentials.password)\n                .build()\n        } catch (ex: Exception) {\n            logger.error("Failed to create DataSource from Vault for role: $role", ex)\n            // Fallback to environment variables\n            return createFallbackDataSource()\n        }\n    }\n    \n    /**\n     * Fallback DataSource using environment variables\n     */\n    private fun createFallbackDataSource(): DataSource {\n        logger.warn("Using fallback DataSource configuration")\n        \n        val jdbcUrl = environment.getProperty("spring.datasource.url")\n            ?: "jdbc:postgresql://localhost:5432/gasolinera_db"\n        val username = environment.getProperty("spring.datasource.username") ?: "gasolinera_user"\n        val password = environment.getProperty("spring.datasource.password") ?: "password"\n        \n        return DataSourceBuilder.create()\n            .driverClassName("org.postgresql.Driver")\n            .url(jdbcUrl)\n            .username(username)\n            .password(password)\n            .build()\n    }\n    \n    /**\n     * Redis Connection Factory configured with Vault\n     */\n    @Bean\n    @ConditionalOnProperty(name = ["vault.redis.enabled"], havingValue = "true", matchIfMissing = true)\n    fun redisConnectionFactory(): RedisConnectionFactory {\n        try {\n            val redisConfig = vaultClient.getSecret("shared/redis")\n                ?: throw VaultException("Redis configuration not found in Vault")\n            \n            val host = redisConfig["host"] as? String ?: "localhost"\n            val port = (redisConfig["port"] as? String)?.toInt() ?: 6379\n            val password = redisConfig["password"] as? String\n            \n            val config = RedisStandaloneConfiguration(host, port)\n            if (!password.isNullOrBlank()) {\n                config.setPassword(password)\n            }\n            \n            logger.info("Creating Redis connection to: $host:$port")\n            return LettuceConnectionFactory(config)\n        } catch (ex: Exception) {\n            logger.error("Failed to create Redis connection from Vault", ex)\n            // Fallback to default configuration\n            return LettuceConnectionFactory()\n        }\n    }\n    \n    /**\n     * RabbitMQ Connection Factory configured with Vault\n     */\n    @Bean\n    @ConditionalOnProperty(name = ["vault.rabbitmq.enabled"], havingValue = "true", matchIfMissing = true)\n    fun rabbitConnectionFactory(): ConnectionFactory {\n        try {\n            val rabbitConfig = vaultClient.getSecret("shared/rabbitmq")\n                ?: throw VaultException("RabbitMQ configuration not found in Vault")\n            \n            val host = rabbitConfig["host"] as? String ?: "localhost"\n            val port = (rabbitConfig["port"] as? String)?.toInt() ?: 5672\n            val username = rabbitConfig["username"] as? String ?: "guest"\n            val password = rabbitConfig["password"] as? String ?: "guest"\n            val virtualHost = rabbitConfig["virtual-host"] as? String ?: "/"\n            \n            val factory = CachingConnectionFactory()\n            factory.setHost(host)\n            factory.setPort(port)\n            factory.setUsername(username)\n            factory.setPassword(password)\n            factory.setVirtualHost(virtualHost)\n            \n            logger.info("Creating RabbitMQ connection to: $host:$port$virtualHost")\n            return factory\n        } catch (ex: Exception) {\n            logger.error("Failed to create RabbitMQ connection from Vault", ex)\n            // Fallback to default configuration\n            val factory = CachingConnectionFactory()\n            factory.setHost("localhost")\n            return factory\n        }\n    }\n    \n    /**\n     * Vault Secret Manager for easy access to secrets\n     */\n    @Bean\n    fun vaultSecretManager(): VaultSecretManager {\n        return VaultSecretManager(vaultClient)\n    }\n    \n    /**\n     * Scheduled task to refresh database credentials\n     */\n    @Scheduled(fixedRate = 1800000) // 30 minutes\n    fun refreshDatabaseCredentials() {\n        try {\n            logger.debug("Refreshing database credentials from Vault...")\n            \n            // Clear cache to force refresh\n            vaultClient.clearCache()\n            \n            // Pre-fetch credentials to warm cache\n            vaultClient.getDatabaseCredentials("gasolinera-readwrite")\n            vaultClient.getDatabaseCredentials("gasolinera-readonly")\n            \n            logger.debug("Database credentials refreshed successfully")\n        } catch (ex: Exception) {\n            logger.warn("Failed to refresh database credentials", ex)\n        }\n    }\n    \n    /**\n     * Get dynamic DataSource for specific role\n     */\n    fun getDataSourceForRole(role: String): DataSource {\n        return dynamicDataSources.computeIfAbsent(role) {\n            createDataSourceFromVault(role)\n        }\n    }\n}\n\n/**\n * Vault Properties Configuration\n */\n@ConfigurationProperties(prefix = "vault")\ndata class VaultProperties(\n    val address: String = "http://localhost:8200",\n    val roleId: String = "",\n    val secretId: String = "",\n    val token: String = "",\n    val namespace: String = "gasolinera-jsm",\n    val tokenRenewalThreshold: Long = 300,\n    val database: DatabaseProperties = DatabaseProperties(),\n    val redis: RedisProperties = RedisProperties(),\n    val rabbitmq: RabbitMQProperties = RabbitMQProperties()\n) {\n    data class DatabaseProperties(\n        val enabled: Boolean = true,\n        val refreshInterval: Long = 1800 // 30 minutes\n    )\n    \n    data class RedisProperties(\n        val enabled: Boolean = true\n    )\n    \n    data class RabbitMQProperties(\n        val enabled: Boolean = true\n    )\n}\n\n/**\n * Vault Secret Manager - High-level interface for secret management\n */\nclass VaultSecretManager(private val vaultClient: VaultClient) {\n    \n    companion object {\n        private val logger = LoggerFactory.getLogger(VaultSecretManager::class.java)\n    }\n    \n    /**\n     * Get JWT configuration\n     */\n    fun getJwtConfig(): JwtConfig {\n        val secrets = vaultClient.getSecret("auth-service")\n            ?: throw VaultException("JWT configuration not found")\n        \n        return JwtConfig(\n            secret = secrets["jwt-secret"] as? String ?: throw VaultException("JWT secret not found"),\n            issuer = secrets["jwt-issuer"] as? String ?: "gasolinera-jsm",\n            accessExpiration = (secrets["jwt-access-expiration"] as? String)?.toLong() ?: 3600,\n            refreshExpiration = (secrets["jwt-refresh-expiration"] as? String)?.toLong() ?: 86400\n        )\n    }\n    \n    /**\n     * Get external API keys\n     */\n    fun getExternalApiKeys(): ExternalApiKeys {\n        val secrets = vaultClient.getSecret("shared/external-apis")\n            ?: throw VaultException("External API keys not found")\n        \n        return ExternalApiKeys(\n            googleMapsApiKey = secrets["google-maps-api-key"] as? String,\n            sendgridApiKey = secrets["sendgrid-api-key"] as? String,\n            twilioApiKey = secrets["twilio-api-key"] as? String,\n            twilioAuthToken = secrets["twilio-auth-token"] as? String\n        )\n    }\n    \n    /**\n     * Get service-specific configuration\n     */\n    fun getServiceConfig(serviceName: String): Map<String, Any> {\n        return vaultClient.getSecret(serviceName) ?: emptyMap()\n    }\n    \n    /**\n     * Encrypt sensitive data\n     */\n    fun encryptSensitiveData(data: String): String {\n        return vaultClient.encrypt("gasolinera-key", data)\n    }\n    \n    /**\n     * Decrypt sensitive data\n     */\n    fun decryptSensitiveData(encryptedData: String): String {\n        return vaultClient.decrypt("gasolinera-key", encryptedData)\n    }\n    \n    /**\n     * Encrypt PII data\n     */\n    fun encryptPiiData(data: String): String {\n        return vaultClient.encrypt("gasolinera-pii-key", data)\n    }\n    \n    /**\n     * Decrypt PII data\n     */\n    fun decryptPiiData(encryptedData: String): String {\n        return vaultClient.decrypt("gasolinera-pii-key", encryptedData)\n    }\n}\n\n/**\n * JWT Configuration data class\n */\ndata class JwtConfig(\n    val secret: String,\n    val issuer: String,\n    val accessExpiration: Long,\n    val refreshExpiration: Long\n)\n\n/**\n * External API Keys data class\n */\ndata class ExternalApiKeys(\n    val googleMapsApiKey: String?,\n    val sendgridApiKey: String?,\n    val twilioApiKey: String?,\n    val twilioAuthToken: String?\n)